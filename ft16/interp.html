<!DOCTYPE html>
<html class="remark-container"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>Interpreters in FLOLAC'14</title>
    <link rel="stylesheet" href="./res/style.css">
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;delayStartupUntil=configured" type="text/javascript"></script>
  </head>
  <body class="remark-container">
    <textarea id="source" style="display: none;">name: inverse
class: inverse, center, middle, front-page
layout: true
---
# Interpreters, FLOLAC'14

.right[unofficial / [suhorng](https://github.com/suhorng/)]

.left[.footnote[This slide: [FT16](https://suhorng.github.io/HaskellExercise/ft16/interp.html)]]
---
layout: false
# FLOLAC'14
http://flolac.iis.sinica.edu.tw/flolac14/doku.php?id=zh-tw:start

- Functional Programming, Dependently Typed Programming

- Logic and Type Theory

- Operational Semantics

- Denotational Semantics

- Lectures on Domain Specific Language
---
# And the derivation trees...
- Typings
\\[
\dfrac
{\dfrac
  {\dfrac{}{- \vdash f : \mathbb{N} \to a} \text{ (var)} \qquad \dfrac{}{- \vdash 3 : \mathbb{N}} \text{ (nat)}}
  {-, f : \mathbb{N} \to a \vdash f\, 3 : a} \text{ (app)}}
{ \vdash \lambda f.\, f\, 3 : (\mathbb{N} \to a) \to a} \text{ (abs)}
\\]

- Operational Semantics
\\[
\dfrac
{\dfrac
  {(\lambda z. z)\, 5 \mapsto z[5 / z]}
  {(\lambda x\, y. x) ((\lambda z. z)\, 5) \mapsto (\lambda x\, y. x)\, 5}}
{(\lambda x\, y. x) ((\lambda z. z)\, 5)\, 3 \mapsto (\lambda x\, y. x)\, 5\, 3}
\\]

- Denotational Semantics

    $[\\![ \mathtt{x} ]\\!] \rho = \rho(\mathtt{x}) $<br/>
    $[\\![ \mathtt{\lambda\, x.e} ]\\!] \rho = f$ where $f(x) = [\\![ \mathtt{e} ]\\!] \rho'$ and $\rho' = \rho [\mathtt{x} \mapsto x]$<br/>
    $[\\![ \mathtt{e1\, e2} ]\\!] \rho = ([\\![ \mathtt{e1} ]\\!] \rho)\, ([\\![ \mathtt{e2} ]\\!] \rho)$

---
# $\lambda$ the ultimate
- The syntax
\\[\\begin{aligned}
v \;\; ::&amp;= \;\; \lambda x.\, e \\\\
&amp;| \;\;\;\;\; \mathbb{N}
\\\\
e \;\; ::&amp;= \;\; x, y, z, \dots \\\\
&amp;| \;\;\;\; \lambda x.\, e \\\\
&amp;| \;\;\;\; e\_1\, e_2 \\\\
&amp;| \;\;\;\; e\_1 + e\_2
\\end{aligned}\\]

<br/>
- In Standard ML,

```ocaml
datatype expr = VAR of string
              | LAM of string * expr
              | AP  of expr * expr
              | NUM of int
              | ADD of expr * expr
```
---
# And the magic computations!
- Recall: value
\\[ \frac{}{(\lambda x.\, M)\, \mathbf{val}} \text{ (fun-v)} \\]
\\[ \frac{n \in \mathbb{N}}{n\, \mathbf{val}} \text{ (nat-v)} \\]

- Call-by-value small-step semantics
\\[ \frac{N\, \mathbf{val}}{(\lambda x.\, M)\,N \mapsto M[N/x]} \text{ (app)} \\]
\\[ \frac{M \mapsto M'}{M\,N \mapsto M'\, N} \text{ (app-l)} \\]
\\[ \frac{N \mapsto N'}{(\lambda x. M)\,N \mapsto (\lambda x. M)\, N'} \text{ (app-r)} \\]
---
# Judgments

XXX TODO
---
# An evaluator, please!
<br/>
- That's simple, I can make it!

```ocaml
datatype value = FN of (value -> value)
               | N  of int
```

```ocaml
fun eval gamma (VAR x) = Env.lookup x gamma
  | eval gamma (LAM (x, e)) = FN (fn v => eval (Env.extend x v gamma) e)
  | eval gamma (AP (e1, e2)) =
      let val (FN f, v) = (eval gamma e1, eval gamma e2)
      in  f v  end
  | eval gamma (NUM n) = N n
  | eval gamma (ADD (e1, e2)) =
      let val (N n, N m) = (eval gamma e1, eval gamma e2)
      in  N (n+m) end
```
---
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
# .center[The two are quite different, so what?]
---
# A CBV small-step semantics interpreter
- They are actually not that unrelated
---
# And the usual interpreter is...
- Oops, not what we have learnt
---
# This is a common big-step semantics
---
# Simply Typed $\lambda$-Calculus
---
# Type checking a term
- Derivation tree is the call-stack!
---
# All are interpreters!
    </textarea>
    <script src="./res/remark-0.6.0.min.js" type="text/javascript"></script>
    <script src="./res/highlight.pack.js"></script>
    <script type="text/javascript">
      /* override default hljs engine to provide Haskell syntax highlight */
      remark.highlighter.engine = hljs;
      var slideshow = remark.create({
        highlightStyle: 'ir_black'
      });
      MathJax.Hub.Config({
        "HTML-CSS": { scale: 75 },
        tex2jax: {
          skipTags: ['code', 'script', 'noscript', 'style' ,'textarea', 'pre'],
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['\\[', '\\]']]
        }
      });
      MathJax.Hub.Configured();
    </script>
    <div class="remark-notes-area">hello world</div>
</body></html>
