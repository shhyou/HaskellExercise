<!DOCTYPE html>
<html class="remark-container"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>實作型別系統</title>
    <link rel="stylesheet" href="./style2.css">
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;delayStartupUntil=configured" type="text/javascript"></script>
  </head>
  <body class="remark-container">
    <textarea id="source" style="display: none;">name: inverse
class: title, inverse, center, middle
# .green[Type Systems] in .lightblue[Practice]<br>

.center[.large[suhorng]]
---
# Language Syntax (Incomplete)

<table style="padding: 1px; margin: 1px;">
  <thead>
    <tr>
      <th>
        In Slide
      </th>
      <th>
        In Code
      </th>
      <th>
        Analogy
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$x$</td>
      <td><pre>VAR "x"</pre></td>
      <td><pre><code class="hljs">x</code></pre></td>
    </tr>
    <tr>
      <td>$\lambda x.e$<br>$\lambda (x\colon t).e$</td>
      <td><pre>LAM ("x", e)
LAM ("x", t, e)
ALAM ("x", t, e)
</pre></td>
      <td>
        <pre><code class="hljs">\x -> e
function (x) { return e; }
\(x :: t) -> e
(x : t) => e
[???](t x) { return e; }
</code></pre>
      </td>
    </tr>
    <tr>
      <td>$e_1\;e_2$</td>
      <td><pre>AP (e1, e2)</pre></td>
      <td>
        <pre><code class="hljs">e1 e2
e1(e2)
</code></pre>
      </td>
    </tr>
    <tr>
      <td>$\mathbf{let}\;x=e_1\;\mathbf{in}\;e_2$</td>
      <td><pre>LET ("x", e1, e2)</pre></td>
      <td><pre><code class="hljs">let x = e1 in e2
val x = e1; e2
</code></pre></td>
    </tr>
    <tr>
      <td>A</td>
      <td><pre>TVAR "A"</pre></td>
      <td><pre><code class="hljs">a, T (Haskell)
typename A, T    (roughly)
</code></pre></td>
    </tr>
    <tr>
      <td>$t_1 \to t_2$</td>
      <td><pre>TARR (t1, t2)</pre></td>
      <td><pre><code class="hljs">t1 -> t2
function&amp;lt;t2(t1)&amp;gt;
t2(*)(t1)        (roughly)
</code></pre></td>
    </tr>
  </tbody>
</table>

---
# What Are Contexts

- Variables visible in current scope

    ```javascript
    function (x) {
      //     ^ here: [x]
      return function (y) { return x; }
      //                    ^ here: [x, y]
      //     ^ here: [x]
    }
    ```

.center[XXX TODO INSERT FIGURE HERE]

- A recurring theme

    ```ocaml
    f (cxt, LAM (x, t, e)) = .... f ((x,t) :: cxt, e) ....
    ```
---
# How Type Systems are Defined
- $e:t$ means $e$ has type $t$

- When $e_1\, e_2$ occurs in some context `cxt`, for some $\alpha,\beta$ we will have...
    * $e_1 : \alpha\to\beta$ in `cxt`
    * $e_2 : \alpha$ in `cxt`
    * $e_1\, e_2 : \beta$ in `cxt`

- The definition is a sort of relation and it holds iff the $\`\`$shape$"$ is correct.
    * $e_1\, e_2$ with $e_1 : \mathbf{char} \to \mathbf{int}$, $e_2 : \mathbf{char}$: OK
    * $e_1\, e_2$ with $e_1 : \mathbf{bool} \to \mathbf{string}$, $e_2 : \mathbf{int}$: NO
    * $e_1\, e_2$ with $e_1 : \mathbf{int}$: NO
---
# Other rules
- $x$ has type $t$ precisely when $(x\colon t)\in\mathtt{cxt}$<br>(Lookup
    the type of $x$ in the current context)
- When $\lambda x.e$ occurs the context `cxt`, for some $\alpha,\beta$ ...
    * $x$ has type $\alpha$

    * $e$ has type $\beta$ in the context $\\{x\colon \alpha\\}\cup \mathtt{cxt}$

    ```cpp
    auto f(int x) -> bool { return x == 0; }

    // 'x' has type 'int'
    // 'x == 0' has type 'bool'
    // 'f' (will) has type  'bool(*)(int)', or roughly 'int -> bool'
    ```

- The case for $\lambda (x\colon t).e$ is similar. Just that $x$ has type $t$.
---
# Problems with Typing Rules
- $e_1\;e_2$ : $\exists \alpha,\beta$ s.t. ...
    * $e_1:\alpha\to\beta$
    * $e_2:\alpha$
    * $e_1\;e_2:\beta$
    *  There's simply no clue for $\alpha$ even if we know $\beta$.

- $\lambda x.e$ : $\exists \alpha,\beta$ s.t. ...
    * $x : \alpha$
    * $e : \beta$
    * $(\lambda x.e) : \alpha\to\beta$
    * Gotta know $\alpha\to\beta$ in order to proceed. Or do we?

---
# First Solution
- Sticking to $\lambda (x\colon t).e$, i.e. users are require to *annotate* $\alpha$
    * Variables are added to the context only in this case, and we
      know their types now

    * $e$ can only refer to variables in current context

    * Hence we can *infer* the type of $e$.

- $x$ : Lookup `cxt`

- $e_1\, e_2$ : Infer the type of $e_1$ and $e_2$, respectively. Check their shape.

- $\lambda (x\colon t).e$ : Infer the type (say $t'$) of $e$. Then the type of
  $\lambda (x\colon t).e$ is $t\to t'$
---
# First Solution

```haskell
let rec infer = function
    cxt, VAR x -> List.assoc x cxt

  | cxt, LAM (x, t1, e) -> TARR (t1, infer ((x,t1)::cxt, e))

  | cxt, (AP (e1, e2) as e) ->

     (match infer (cxt, e1), infer (cxt, e2) with
       TARR (t1, t2), t1' when t1 = t1' -> t2
     | _ -> ERROR!!!
```

- Problem: it's too verbose

    ```haskell
    \(z : A). let ididid = \(h : (A &rightarrow; A) &rightarrow; A &rightarrow; A). h in

              ididid (\(f : A &rightarrow; A). f) (\(x:A).x) z
    ```

    - Why bother annotating $f$ and $x$ if the type of $\mathit{ididid}$ is known
        (hence the type of its argumetns)?

---
# Improvement via Bidirectional Typing

- Another motivation: Originally, the typing rules are relations and might not be
    syntax-directed

$\displaystyle \frac{(x:t)\in \Gamma}{\Gamma \vdash x:t} \quad \quad \frac{\Gamma,(x\colon t)\vdash e:t'}{\Gamma \vdash (\lambda x.e):t\to t'} \quad\quad \frac{\Gamma \vdash e_1:t\to t' \quad \Gamma \vdash e_2:t}{\Gamma \vdash e_1\,e_2:t'}$

--

- Annotate judgments with I/O modes to get a function

\\[ \Gamma\_\mathtt{in} \vdash x\_\mathtt{in}:t\_\mathtt{out}\\]

\\[ \text{recursive call} \Uparrow\;\; \frac{(\Gamma,x\colon t)\_\mathtt{shown\\\_in}\vdash e:t'\_\mathtt{assumed\\\_out}}{\Gamma\_\mathtt{assumed\\\_in} \vdash (\lambda x.e):(t\to t')\_\mathtt{shown\\\_out}} \;\; \Downarrow \text{return} \\]

- Separating type **checking** and **inference**:

\\[ \Gamma\_\mathtt{in} \vdash e\_\mathtt{in}\Rightarrow t\_\mathtt{out} \;\;\text{(infer)}\quad\quad \Gamma\_\mathtt{in} \vdash e\_\mathtt{in}\Leftarrow t\_\mathtt{in} \;\;\text{(check)}\\]

---
# Bidirectional Typing, Intuitively

- Separating type **checking** and **inference**. If we already know $t$, **check** $e$ against $t$. Otherwise **infer** $t$ from $e$.

    ```haskell
    val check : context * expr *  type -> unit
    val infer : context * expr -> type
    ```

- $x$: Simple, look up the type of $x$ in `cxt`

- If an expression $e$ can be inferred to have type $t$, then it can be checked
    against $t$. That is,

    ```haskell
    function check(cxt, e, t):
      let t' = infer(cxt, e)
      if t &ne; t':
        error
    ```
---
# Bidirectional Typing, Intuitively

- The case $e_1\, e_2$
    1. $e_1:\alpha\to\beta$
    1. $e_2:\alpha$
    1. $e_1\,e_2:\beta$

- There's no way to know $\alpha$, regardless whether $\beta$ is known or not.
- Must **infer** the type of $e_1$. Then $e_2$ can be check to have type $\alpha$.
    Luckily, most cases the funtion $e_1$ are known from the context.

    ```haskell
    function infer(cxt, AP (e1, e2)):
      -- Failed if e1 is not of function type
      let TARR (t1, t2) = infer(cxt, e1)
      check(cxt, e2, t1)
      return t2
    ```
---
# Bidirectional Typing, Intuitively

- The case $\lambda x.e$
    1. $x : \alpha$
    1. $e : \beta$
    1. $(\lambda x.e) : \alpha\to\beta$

- To check is .delete[human]simple.

    ```haskell
    function check(cxt, LAM (x, e), TARR (t, t')):
      check((x,t) :: cxt,  e,  t')
    ```

- To infer, .delete[divine] $x$ needs annotaiton.

    ```haskell
    function infer(cxt, ALAM (x, t, e)):
      return (TARR (t, infer ((x,t) :: cxt,  e)))
    ```
---
# Bidirectional Typing, Intuitively

- Even better: we allow the user annotate expressions with types

- An expression $\`\`e:t"$ can be **inferred** to have type $t$
  while we check $e$ against $t$.

    ```haskell
    function infer(cxt, ANNO (e, t)):
      check(cxt, e, t)
      return t
    ```

- Examples

    ```haskell
    (\x. \f. f x) : (A &rightarrow; (A &rightarrow; B) &rightarrow; B)

    \(z : A). let ididid = \(h : (A &rightarrow; A) &rightarrow; A &rightarrow; A). h in

              ididid (\f.f) (\x.x) z
    ```
---
# An Equational Approach
---
# Polymorphism: Generic the Easy Way
---
# Upgrading our Algorithm
---
# References
1. Frank Pfenning. CMU CS15-312 *Foundations of Programming Languages*
    http://www.cs.cmu.edu/~fp/courses/15312-f04/index.html

1. D. Christiansen. *Bidirectional Typing Rules: A Tutorial*
    http://www.itu.dk/people/drc/tutorials/bidirectional.pdf

---
# Language Syntax Quick Guide

<table>
  <thead>
    <tr>
      <th>
        In Slide
      </th>
      <th>
        In Code
      </th>
      <th>
        Analogy
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$x$</td>
      <td><pre>VAR "x"</pre></td>
      <td><pre><code class="hljs">x</code></pre></td>
    </tr>
    <tr>
      <td>$\lambda x.e$<br>$\lambda (x\colon t).e$</td>
      <td><pre>LAM ("x", e)
LAM ("x", t, e)
ALAM ("x", t, e)
</pre></td>
      <td>
        <pre><code class="hljs">\x -> e
function (x) { return e; }
\(x :: t) -> e
(x : t) => e
[???](t x) { return e; }
</code></pre>
      </td>
    </tr>
    <tr>
      <td>$e_1\;e_2$</td>
      <td><pre>AP (e1, e2)</pre></td>
      <td>
        <pre><code class="hljs">e1 e2
e1(e2)
</code></pre>
      </td>
    </tr>
    <tr>
      <td>$\mathbf{let}\;x=e_1\;\mathbf{in}\;e_2$</td>
      <td><pre>LET ("x", e1, e2)</pre></td>
      <td><pre><code class="hljs">let x = e1 in e2
val x = e1; e2
</code></pre></td>
    </tr>
    <tr>
      <td>$e \colon t$</td>
      <td><pre>ANNO (e,t)</pre></td>
      <td><pre><code class="hljs">e :: t
</code></pre></td>
    </tr>
    <tr>
      <td>$\Lambda \alpha.e$</td>
      <td><pre>TLAM ("a", e)</pre></td>
      <td><pre><code class="hljs">def foo[a](...) = ...
fn bar&amp;lt;a&amp;gt;(...) { ... }
template&amp;lt;typename a&amp;gt; e
</code></pre></td>
    </tr>
    <tr>
      <td>$e\;[t]$</td>
      <td><pre>TAP (e, t)</pre></td>
      <td><pre><code class="hljs">e&amp;lt;t&amp;gt;()
</code></pre></td>
    </tr>
  </tbody>
</table>
</textarea>
    <script src="./remark-0.10.2.min.js" type="text/javascript"></script>
    <script type="text/javascript">
      var slideshow = remark.create({
        highlightStyle: 'ir_black'
      });
      MathJax.Hub.Config({
        "HTML-CSS": { scale: 75 },
        tex2jax: {
          skipTags: ['code', 'script', 'noscript', 'style' ,'textarea', 'pre'],
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['\\[', '\\]']]
        }
      });
      MathJax.Hub.Configured();
    </script>
    <div class="remark-notes-area">hello world</div>
</body></html>
