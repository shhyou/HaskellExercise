<!DOCTYPE html>
<html class="remark-container"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>實作型別系統</title>
    <link rel="stylesheet" href="./style2.css">
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;delayStartupUntil=configured" type="text/javascript"></script>
  </head>
  <body class="remark-container">
    <textarea id="source" style="display: none;">name: inverse
class: title, inverse, center, middle
# .green[Type Systems] in .lightblue[Practice]<br>

.center[.large[suhorng]]
---
# Language Syntax (Incomplete)

<table style="padding: 1px; margin: 1px;">
  <thead>
    <tr>
      <th>
        In Slide
      </th>
      <th>
        In Code
      </th>
      <th>
        Analogy
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$x$</td>
      <td><pre>VAR "x"</pre></td>
      <td><pre><code class="hljs">x</code></pre></td>
    </tr>
    <tr>
      <td>$\lambda x.e$<br>$\lambda (x\colon t).e$</td>
      <td><pre>LAM ("x", e)
LAM ("x", t, e)
ALAM ("x", t, e)
</pre></td>
      <td>
        <pre><code class="hljs">\x -> e
function (x) { return e; }
\(x :: t) -> e
(x : t) => e
[???](t x) { return e; }
</code></pre>
      </td>
    </tr>
    <tr>
      <td>$e_1\;e_2$</td>
      <td><pre>AP (e1, e2)</pre></td>
      <td>
        <pre><code class="hljs">e1 e2
e1(e2)
</code></pre>
      </td>
    </tr>
    <tr>
      <td>$\mathbf{let}\;x=e_1\;\mathbf{in}\;e_2$</td>
      <td><pre>LET ("x", e1, e2)</pre></td>
      <td><pre><code class="hljs">let x = e1 in e2
val x = e1; e2
</code></pre></td>
    </tr>
    <tr>
      <td>A</td>
      <td><pre>TVAR "A"</pre></td>
      <td><pre><code class="hljs">a, T (Haskell)
typename A, T    (roughly)
</code></pre></td>
    </tr>
    <tr>
      <td>$t_1 \to t_2$</td>
      <td><pre>TARR (t1, t2)</pre></td>
      <td><pre><code class="hljs">t1 -> t2
function&amp;lt;t2(t1)&amp;gt;
t2(*)(t1)        (roughly)
</code></pre></td>
    </tr>
  </tbody>
</table>

---
# What Are Contexts

- Variables visible in current scope

    ```javascript
    function (x) {
      //     ^ here: [x]
      return function (y) { return x; }
      //                    ^ here: [x, y]
      //     ^ here: [x]
    }
    ```

.center[XXX TODO INSERT FIGURE HERE]

- A recurring theme

    ```ocaml
    f (cxt, LAM (x, t, e)) = .... f ((x,t) :: cxt, e) ....
    ```
---
# How Type Systems are Defined
- $e:t$ means $e$ has type $t$

- When $e_1\, e_2$ occurs in some context `cxt`, for some $\alpha,\beta$ we will have...
    * $e_1 : \alpha\to\beta$ in `cxt`
    * $e_2 : \alpha$ in `cxt`
    * $e_1\, e_2 : \beta$ in `cxt`

- The definition is a sort of relation and it holds iff the $\`\`$shape$"$ is correct.
    * $e_1\, e_2$ with $e_1 : \mathbf{char} \to \mathbf{int}$, $e_2 : \mathbf{char}$: OK
    * $e_1\, e_2$ with $e_1 : \mathbf{bool} \to \mathbf{string}$, $e_2 : \mathbf{int}$: NO
    * $e_1\, e_2$ with $e_1 : \mathbf{int}$: NO
---
# Other rules
- $x$ has type $t$ precisely when $(x\colon t)\in\mathtt{cxt}$<br>(Lookup
    the type of $x$ in the current context)
- When $\lambda x.e$ occurs the context `cxt`, for some $\alpha,\beta$ ...
    * $x$ has type $\alpha$

    * $e$ has type $\beta$ in the context $\\{x\colon \alpha\\}\cup \mathtt{cxt}$

    ```cpp
    auto f(int x) -> bool { return x == 0; }

    // 'x' has type 'int'
    // 'x == 0' has type 'bool'
    // 'f' (will) has type  'bool(*)(int)', or roughly 'int -> bool'
    ```

- The case for $\lambda (x\colon t).e$ is similar. Just that $x$ has type $t$.
---
# Problems with Typing Rules
- $e_1\;e_2$ : $\exists \alpha,\beta$ s.t. ...
    * $e_1:\alpha\to\beta$
    * $e_2:\alpha$
    * $e_1\;e_2:\beta$
    *  There's simply no clue for $\alpha$ even if we know $\beta$.

- $\lambda x.e$ : $\exists \alpha,\beta$ s.t. ...
    * $x : \alpha$
    * $e : \beta$
    * $(\lambda x.e) : \alpha\to\beta$
    * Gotta know $\alpha\to\beta$ in order to proceed. Or do we?

---
# First Solution
- Sticking to $\lambda (x\colon t).e$, i.e. users are require to *annotate* $\alpha$
    * Variables are added to the context only in this case, and we
      know their types now

    * $e$ can only refer to variables in current context

    * Hence we can *infer* the type of $e$.

- $x$ : Lookup `cxt`

- $e_1\, e_2$ : Infer the type of $e_1$ and $e_2$, respectively. Check their shape.

- $\lambda (x\colon t).e$ : Infer the type (say $t'$) of $e$. Then the type of
  $\lambda (x\colon t).e$ is $t\to t'$
---
# First Solution

```haskell
let rec infer = function
    cxt, VAR x -> List.assoc x cxt

  | cxt, LAM (x, t1, e) -> TARR (t1, infer ((x,t1)::cxt, e))

  | cxt, (AP (e1, e2) as e) ->

     (match infer (cxt, e1), infer (cxt, e2) with
       TARR (t1, t2), t1' when t1 = t1' -> t2
     | _ -> ERROR!!!
```

- Problem: it's too verbose

    ```haskell
    \(z : A). let ididid = \(h : (A &rightarrow; A) &rightarrow; A &rightarrow; A). h in

              ididid (\(f : A &rightarrow; A). f) (\(x:A).x) z
    ```

    - Why bother annotating $f$ and $x$ if the type of $\mathit{ididid}$ is known
        (hence the type of its argumetns)?

---
# Improvement via Bidirectional Typing

- Another motivation: Originally, the typing rules are relations and might not be
    syntax-directed

$\displaystyle \frac{(x:t)\in \Gamma}{\Gamma \vdash x:t} \quad \quad \frac{\Gamma,(x\colon t)\vdash e:t'}{\Gamma \vdash (\lambda x.e):t\to t'} \quad\quad \frac{\Gamma \vdash e_1:t\to t' \quad \Gamma \vdash e_2:t}{\Gamma \vdash e_1\,e_2:t'}$

--

- Annotate judgments with I/O modes to get a function

\\[ \Gamma\_\mathtt{in} \vdash x\_\mathtt{in}:t\_\mathtt{out}\\]

\\[ \text{recursive call} \Uparrow\;\; \frac{(\Gamma,x\colon t)\_\mathtt{shown\\\_in}\vdash e:t'\_\mathtt{assumed\\\_out}}{\Gamma\_\mathtt{assumed\\\_in} \vdash (\lambda x.e):(t\to t')\_\mathtt{shown\\\_out}} \;\; \Downarrow \text{return} \\]

- Separating type **checking** and **inference**:

\\[ \Gamma\_\mathtt{in} \vdash e\_\mathtt{in}\Rightarrow t\_\mathtt{out} \;\;\text{(infer)}\quad\quad \Gamma\_\mathtt{in} \vdash e\_\mathtt{in}\Leftarrow t\_\mathtt{in} \;\;\text{(check)}\\]

---
# Bidirectional Typing, Intuitively

- Separating type **checking** and **inference**. If we already know $t$, **check** $e$ against $t$. Otherwise **infer** $t$ from $e$.

    ```haskell
    val check : context * expr *  type -> unit
    val infer : context * expr -> type
    ```

- $x$: Simple, look up the type of $x$ in `cxt`

- If an expression $e$ can be inferred to have type $t$, then it can be checked
    against $t$. That is,

    ```haskell
    function check(cxt, e, t):
      let t' = infer(cxt, e)
      if t &ne; t':
        error
    ```
---
# Bidirectional Typing, Intuitively

- The case $e_1\, e_2$
    1. $e_1:\alpha\to\beta$
    1. $e_2:\alpha$
    1. $e_1\,e_2:\beta$

- There's no way to know $\alpha$, regardless whether $\beta$ is known or not.
- Must **infer** the type of $e_1$. Then $e_2$ can be check to have type $\alpha$.
    Luckily, most cases the funtion $e_1$ are known from the context.

    ```haskell
    function infer(cxt, AP (e1, e2)):
      -- Failed if e1 is not of function type
      let TARR (t1, t2) = infer(cxt, e1)
      check(cxt, e2, t1)
      return t2
    ```
---
# Bidirectional Typing, Intuitively

- The case $\lambda x.e$
    1. $x : \alpha$
    1. $e : \beta$
    1. $(\lambda x.e) : \alpha\to\beta$

- To check is .delete[human]simple.

    ```haskell
    function check(cxt, LAM (x, e), TARR (t, t')):
      check((x,t) :: cxt,  e,  t')
    ```

- To infer, .delete[divine] $x$ needs an annotation.

    ```haskell
    function infer(cxt, ALAM (x, t, e)):
      return (TARR (t, infer ((x,t) :: cxt,  e)))
    ```
---
# Bidirectional Typing, Intuitively

- Even better: we allow the user annotate expressions with types

- An expression $\`\`e:t"$ can be **inferred** to have type $t$
  while we check $e$ against $t$.

    ```haskell
    function infer(cxt, ANNO (e, t)):
      check(cxt, e, t)
      return t
    ```

- Examples

    ```haskell
    (\x. \f. f x) : (A &rightarrow; (A &rightarrow; B) &rightarrow; B)

    \(z : A). let ididid = \(h : (A &rightarrow; A) &rightarrow; A &rightarrow; A). h in

              ididid (\f.f) (\x.x) z
    ```
---
# An Equational Approach
- The case $e_1\, e_2$
    1. $e_1:\alpha\to\beta$
    1. $e_2:\alpha$
    1. $e_1\,e_2:\beta$

- Does not knowing $\alpha$ really matter?

    * Set up a constraint and solve it latter!

    * Let $e_1 : t$ and $e_2:t'$

    * $t=t'\to t''$ for some unknown $t''$
---
# An Equational Approach

.center[.redbbox[$\lambda f.\lambda z. f z z$]]

- Allocate fresh unknown $t_1$

.pull-left[
]

.pull-right[
- Case $\lambda x.e$ with $x :\equiv f$,$e:\equiv \lambda z. f z z$
    * $x:\alpha$
    * $e:\beta$
    * $(\lambda x.e):\alpha\to\beta$

- Context: $[]$
]

Now $f:t_1$
---
# An Equational Approach

.center[$\lambda f.$.redbbox[$\lambda z. f z z$]]

- Allocate fresh unknown $t_2$

.pull-left[
]

.pull-right[
- Case $\lambda x.e$ with $x :\equiv z$,$e:\equiv f z z$
    * $x:\alpha$
    * $e:\beta$
    * $(\lambda x.e):\alpha\to\beta$

- Context: $[(f\colon t_1)]$
]

Now $f:t_1 \quad\quad z:t_2$
---
# An Equational Approach

.center[$\lambda f.\lambda z.$.redbbox[$f z z$]]

- Recursion.

.pull-left[
]

.pull-right[
- Case $e_1\,e_2$ with $e_1 :\equiv fz$,$e_2:\equiv z$
    * $e_1:\alpha\to\beta$
    * $e_2:\alpha$
    * $e_1\,e_2:\beta$

- Context: $[(f\colon t_1),(z\colon t_3)]$
]

Now $f:t_1 \quad\quad z:t_2$
---
# An Equational Approach

.center[$\lambda f.\lambda z.$.redbbox[$f z$] $z$]

- Recursion.

.pull-left[
]

.pull-right[
- Case $e_1\,e_2$ with $e_1 :\equiv f$,$e_2:\equiv z$
    * $e_1:\alpha\to\beta$
    * $e_2:\alpha$
    * $e_1\,e_2:\beta$

- Context: $[(f\colon t_1),(z\colon t_3)]$
]

Now $f:t_1 \quad\quad z:t_2$
---
# An Equational Approach

.center[$\lambda f.\lambda z.$.redbbox[$f$] $z z$]

- Lookup context and return $t_1$.

.pull-left[
]

.pull-right[
- Case $e_1\,e_2$ with $e_1 :\equiv f$,$e_2:\equiv z$
    * $e_1:\alpha\to\beta$
    * $e_2:\alpha$
    * $e_1\,e_2:\beta$

- Context: $[(f\colon t_1),(z\colon t_3)]$
]

Now $f:t_1 \quad\quad z:t_2$
---
# An Equational Approach

.center[$\lambda f.\lambda z.$ $f$.redbbox[$z$]$z$]

- Lookup context and return $t_2$.

.pull-left[
]

.pull-right[
- Case $e_1\,e_2$ with $e_1 :\equiv f$,$e_2:\equiv z$
    * $e_1:\alpha\to\beta$
    * $e_2:\alpha$
    * $e_1\,e_2:\beta$

- Context: $[(f\colon t_1),(z\colon t_3)]$
]

Now $f:t_1 \quad\quad z:t_2$
---
# An Equational Approach

.center[$\lambda f.\lambda z.$.redbbox[$f z$]$z$]

- Allocate fresh unknown $t_3$. Return $t_3$.

.pull-left[
$t_1=t_2\to t_3$
]

.pull-right[
- Case $e_1\,e_2$ with $e_1 :\equiv f$,$e_2:\equiv z$
    * $e_1:\alpha\to\beta$
    * $e_2:\alpha$
    * $e_1\,e_2:\beta$

- Context: $[(f\colon t_1),(z\colon t_3)]$
]

Now $f:t_1 \quad\quad z:t_2$
---
# An Equational Approach

.center[$\lambda f.\lambda z.$ $fz$.redbbox[$z$]]

- Lookup context and return $t_2$.

.pull-left[
$t_1=t_2\to t_3$
]

.pull-right[
- Case $e_1\,e_2$ with $e_1 :\equiv fz$,$e_2:\equiv z$
    * $e_1:\alpha\to\beta$
    * $e_2:\alpha$
    * $e_1\,e_2:\beta$

- Context: $[(f\colon t_1),(z\colon t_3)]$
]

Now $f:t_1 \quad\quad z:t_2$
---
# An Equational Approach

.center[$\lambda f.\lambda z.$.redbbox[$f z z$]]

- Allocate fresh unknown $t_4$. Return $t_4$.

.pull-left[
$t_1=t_2\to t_3$<br>
$t_3=t_2\to t_4$
]

.pull-right[
- Case $e_1\,e_2$ with $e_1 :\equiv fz$,$e_2:\equiv z$
    * $e_1:\alpha\to\beta$
    * $e_2:\alpha$
    * $e_1\,e_2:\beta$

- Context: $[(f\colon t_1),(z\colon t_3)]$
]

Now $f:t_1 \quad\quad z:t_2 \quad\quad fz:t_3$
---
# An Equational Approach

.center[$\lambda f.$.redbbox[$\lambda z.f z z$]]

- Return $t_2\to t_4$

.pull-left[
$t_1=t_2\to t_3$<br>
$t_3=t_2\to t_4$
]

.pull-right[
- Case $\lambda x.e$ with $x :\equiv z$,$e:\equiv f z z$
    * $x:\alpha$
    * $e:\beta$
    * $(\lambda x.e):\alpha\to\beta$

- Context: $[(f\colon t_1)]$
]

Now $f:t_1 \quad\quad z:t_2 \quad\quad fz:t_3 \quad\quad fzz:t_4$
---
# An Equational Approach

.center[.redbbox[$\lambda f.\lambda z. f z z$]]

- Return $t_1\to (t_2\to t_4)$

.pull-left[
$t_1=t_2\to t_3$<br>
$t_3=t_2\to t_4$
]

.pull-right[
- Case $\lambda x.e$ with $x :\equiv f$,$e:\equiv \lambda z. f z z$
    * $x:\alpha$
    * $e:\beta$
    * $(\lambda x.e):\alpha\to\beta$

- Context: $[]$
]

Now $f:t_1 \quad\quad z:t_2 \quad\quad fz:t_3 \quad\quad fzz:t_4 \quad\quad (\lambda z.fzz):t_2\to t_4$
---
# Solving Equations
- At top level: $(\lambda f.\lambda z. f z z):t_1\to t_2\to t_4$

- Now $(f:t_1), (z:t_2), (fz:t_3), (fzz:t_4)$ and $(\lambda z.fzz):t_2\to t_4$ with

    $t_1=t_2\to t_3$<br>
    $t_3=t_2\to t_4$
---
# Solving Equations
- At top level: $(\lambda f.\lambda z. f z z):(t_2\to t_3)\to t_2\to t_4$

- Now $(f:t_2\to t_3), (z:t_2), (fz:t_3), (fzz:t_4)$ and $(\lambda z.fzz):t_2\to t_4$ with

    $t_1=t_2\to t_3$<br>
    $t_3=t_2\to t_4$

- Substitute $t_2\to t_3$ for $t_1$!
---
# Solving Equations
- At top level: $(\lambda f.\lambda z. f z z):(t_2\to t_2\to t_4)\to t_2\to t_4$

- Now $(f:t_2\to t_2\to t_4), (z:t_2), (fz:t_2\to t_4), (fzz:t_4)$ and $(\lambda z.fzz):t_2\to t_4$ with

    $t_1=t_2\to t_3$<br>
    $t_3=t_2\to t_4$

- Substitute $t_2\to t_4$ for $t_3$!

--

.center[.greenbbox[$(\lambda f.\lambda z. f z z):(A\to A\to B)\to A\to B$]]
---
# Disjoint Sets to the Rescue

- Union and Find!

- Our data type for meta-types:

    ```haskell
    type typ = TVAR of (metavar ref)
             | TARR of typ * typ
    and metavar = UNBOUND of string
                | LINK of typ
    ```

    * A `'a ref` is a mutable variable of type `'a`

- Example

    ```haskell
    let tvar = ref (UNBOUND "x")
    let t = TARR (TVAR tvar, TVAR var)
    print t
    --  => x -> x

    let t' = TVAR (ref (UNBOUND "A"))
    tvar := BOUND (TARR (t', t'))
    print t
    --  => (t -> t) -> t -> t
    ```
---
# Unification: Solve an Equation
- $t\_i = T$ (or $= (\\\_ \to \\\_), ...$) &Rightarrow; substitute RHS for $t\_i$ (*)

- $t_1\to t_2=t_3\to t_4$ &Rightarrow; Solve $t_1=t_3$, $t_2=t_4$ recursively.

```haskell
function unify(TVAR (r = LINK t), t'):   -- &leftarrow; Find
  unify(t, t')

function unify(TVAR (r = UNBOUND x), TVAR (s = UNBOUND y)), x == y:
  no-op

function unify(TVAR (r = UNBOUND x), t): -- &leftarrow; Union
  if occurs(x, t):  -- &leftarrow; See &diamond;&diamond;page
    ERROR!!
  r := t

function unify(TARR (t1, t2), TARR (t3, t4)):
  unify(t1, t3)
  unify(t2, t4)
```

- The case for `t, TVAR _` the same
---
# Final Step
- Case $x$
    ```haskell
    function typeinfer(cxt, VAR x):
      return (lookup x in cxt)
    ```

- Case $e_1\,e_2$
    ```haskell
    function typeinfer(cxt, AP (e1, e2)):
      let t1 = typeinfer(cxt, e1)
      let t2 = typeinfer(cxt, e2)
      let t = fresh_var()
      unify(t1, TARR (t2, t))
      return t
    ```

- Case $\lambda x.e$
    ```haskell
    function typeinfer(cxt, LAM (x, e)):
      let t = fresh_var()
      return (TARR (t, typeinfer((x,t) :: cxt,  e)))
    ```
---
# Occurs Check
- Infer $\lambda x.xx$: Get equation $x:t_1$, $xx:t_2$ and $t_1=t_1\to t_2$

    * Cannot eliminate $t_1$ by substituting $t_1\to t_2$ for $t_1$!

.center[XXX TODO INSERT FIGURE HERE]

- In equation $t_i = T$, it's an error if $t_i$ occurs in $T$.
---
# Polymorphism: Generic the Easy Way
- C++ Style:

    ```cpp
    template&lt;typename a&gt; a id(a x) { return x; }
    id&lt;int&gt;(...)
    id&lt;shared_ptr&lt;expr_t&gt;&gt;(...)
    ```

    Different code (semantics) when instantiated with different types

- Functional Style:
---
# Upgrading our Algorithm
---
# References
1. Frank Pfenning. CMU CS15-312 *Foundations of Programming Languages*
    http://www.cs.cmu.edu/~fp/courses/15312-f04/index.html

1. D. Christiansen. *Bidirectional Typing Rules: A Tutorial*
    http://www.itu.dk/people/drc/tutorials/bidirectional.pdf

---
# Language Syntax Quick Guide

<table>
  <thead>
    <tr>
      <th>
        In Slide
      </th>
      <th>
        In Code
      </th>
      <th>
        Analogy
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$x$</td>
      <td><pre>VAR "x"</pre></td>
      <td><pre><code class="hljs">x</code></pre></td>
    </tr>
    <tr>
      <td>$\lambda x.e$<br>$\lambda (x\colon t).e$</td>
      <td><pre>LAM ("x", e)
LAM ("x", t, e)
ALAM ("x", t, e)
</pre></td>
      <td>
        <pre><code class="hljs">\x -> e
function (x) { return e; }
\(x :: t) -> e
(x : t) => e
[???](t x) { return e; }
</code></pre>
      </td>
    </tr>
    <tr>
      <td>$e_1\;e_2$</td>
      <td><pre>AP (e1, e2)</pre></td>
      <td>
        <pre><code class="hljs">e1 e2
e1(e2)
</code></pre>
      </td>
    </tr>
    <tr>
      <td>$\mathbf{let}\;x=e_1\;\mathbf{in}\;e_2$</td>
      <td><pre>LET ("x", e1, e2)</pre></td>
      <td><pre><code class="hljs">let x = e1 in e2
val x = e1; e2
</code></pre></td>
    </tr>
    <tr>
      <td>$e \colon t$</td>
      <td><pre>ANNO (e,t)</pre></td>
      <td><pre><code class="hljs">e :: t
</code></pre></td>
    </tr>
    <tr>
      <td>$\Lambda \alpha.e$</td>
      <td><pre>TLAM ("a", e)</pre></td>
      <td><pre><code class="hljs">def foo[a](...) = ...
fn bar&amp;lt;a&amp;gt;(...) { ... }
template&amp;lt;typename a&amp;gt; e
</code></pre></td>
    </tr>
    <tr>
      <td>$e\;[t]$</td>
      <td><pre>TAP (e, t)</pre></td>
      <td><pre><code class="hljs">e&amp;lt;t&amp;gt;()
</code></pre></td>
    </tr>
  </tbody>
</table>
</textarea>
    <script src="./remark-0.10.2.min.js" type="text/javascript"></script>
    <script type="text/javascript">
      var slideshow = remark.create({
        highlightStyle: 'ir_black'
      });
      MathJax.Hub.Config({
        "HTML-CSS": { scale: 75 },
        tex2jax: {
          skipTags: ['code', 'script', 'noscript', 'style' ,'textarea', 'pre'],
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['\\[', '\\]']]
        }
      });
      MathJax.Hub.Configured();
    </script>
    <div class="remark-notes-area">hello world</div>
</body></html>
