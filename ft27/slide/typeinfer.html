<!DOCTYPE html>
<html class="remark-container"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>實作型別系統</title>
    <link rel="stylesheet" href="./style2.css">
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;delayStartupUntil=configured" type="text/javascript"></script>
  </head>
  <body class="remark-container">
    <textarea id="source" style="display: none;">name: inverse
class: title, inverse, center, middle
# .green[Type Systems] in .lightblue[Practice]<br>

.center[.large[suhorng]]
---
# Language Syntax (Incomplete)

<table>
  <thead>
    <tr>
      <th>
        In Slide
      </th>
      <th>
        In Code
      </th>
      <th>
        Analogy
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$x$</td>
      <td><pre>VAR "x"</pre></td>
      <td><pre><code class="hljs">x</code></pre></td>
    </tr>
    <tr>
      <td>$\lambda x.e$<br>$\lambda (x\colon t).e$</td>
      <td><pre>LAM ("x", e)
LAM ("x", t, e)
ALAM ("x", t, e)
</pre></td>
      <td>
        <pre><code class="hljs">\x -> e
function (x) { return e; }
\(x :: t) -> e
(x : t) => e
[???](t x) { return e; }
</code></pre>
      </td>
    </tr>
    <tr>
      <td>$e_1\;e_2$</td>
      <td><pre>AP (e1, e2)</pre></td>
      <td>
        <pre><code class="hljs">e1 e2
e1(e2)
</code></pre>
      </td>
    </tr>
    <tr>
      <td>$\mathbf{let}\;x=e_1\;\mathbf{in}\;e_2$</td>
      <td><pre>LET ("x", e1, e2)</pre></td>
      <td><pre><code class="hljs">let x = e1 in e2
val x = e1; e2
</code></pre></td>
    </tr>
  </tbody>
</table>
---
# What Are Contexts

- Variables visible in current scope

    ```javascript
    function (x) {
      //     ^ here: [x]
      return function (y) { return x; }
      //                    ^ here: [x, y]
      //     ^ here: [x]
    }
    ```

.center[XXX TODO INSERT FIGURE HERE]

- A recurring theme

    ```ocaml
    f (cxt, LAM (x, t, e)) = ... f ((x,t) :: cxt, e) ...
    ```
---
# How Type Systems are Defined
- When $e_1\; e_2$ occurs in some context `cxt`, for some $\alpha,\beta$ we will have...
    * $e_1$ has type $\alpha\to\beta$ in the context `cxt`
    * $e_2$ has type $\alpha$ in the context `cxt`
    * $e_1\; e_2$ has type $\beta$ in the context `cxt`

- The definition a sort of relation, and it holds iff the $\$\$$shape$"$ is correct.
    * $e_1\; e_2$ with $e_1 \colon \mathbf{char} \to \mathbf{int}$, $e_2 \colon \mathbf{char}$: OK
    * $e_1\; e_2$ with $e_1 \colon \mathbf{bool} \to \mathbf{string}$, $e_2 \colon \mathbf{int}$: NO
    * $e_1\; e_2$ with $e_1 \colon \mathbf{int}$, $e_2 \colon ???$: NO
---
# Other rules
- $x$ has type $t$ precisely when $(x\colon t)\in\mathtt{cxt}$ (We lookup
    the type of $x$ in the current context)
- When $\lambda x.e$ occurs the context `cxt`, for some $\alpha,\beta$ ...
    * $x$ has type $\alpha$

    * $e$ has type $\beta$ in the context $\\{x\colon \alpha\\}\cup \mathtt{cxt}$

    ```cpp
    auto f(int x) -> bool { return x == 0; }

    // 'x' has type 'int'
    // 'x == 0' has type 'bool'
    // 'f' has type  'bool(*)(int)', or roughly 'int -> bool'
    ```

- The case for $\lambda (x\colon t).e$ is similar. Just that $x$ has type $t$.
---
# Problems with Typing Rules
- $e_1\;e_2$ : $\exists \alpha,\beta$ s.t. ...
    * $e_1\colon\alpha\to\beta$
    * $e_2:\alpha$
    * $e_1\;e_2:\beta$
    *  There's simply no clue for $\alpha$ even if we know $\beta$.

- $\lambda x.e$ : $\exists \alpha,\beta$ s.t. ...
    * $x\colon \alpha$
    * $e\colon \beta$
    * $(\lambda x.e)\colon \alpha\to\beta$
    * Gotta know $\alpha\to\beta$ in order to proceed. Or do we?

---
# First Solution
- Sticking to $\lambda (x\colon t).e$, i.e. users are require to *annotate* $\alpha$
    * Variables are added to the context only in this case, and we
      know their types now

    * $e$ can only refer to variables in current context

    * Hence we can *infer* the type of $e$.

- $e_1\; e_2$ : Infer the type of $e_1$ and $e_2$, respectively. Check their shape.

- $\lambda (x\colon t).e$ : Infer the type (say $t'$) of $e$. Then the type of
  $\lambda (x\colon t).e$ is $t\to t'$
---
# First Solution

```haskell
let rec infer = function
    cxt, VAR x -> List.assoc x cxt

  | cxt, LAM (x, t1, e) -> TARR (t1, infer ((x,t1)::cxt, e))

  | cxt, (AP (e1, e2) as e) ->

     (match infer (cxt, e1), infer (cxt, e2) with
       TARR (t1, t2), t1' when t1 = t1' -> t2
     | _ -> ERROR!!!
```
---
# Improvement via Bidirectional Typing
---
# A Mathematical Approach
---
# Polymorphism: Generics the Easy Way
---
# Upgrading our Algorithm
---
# Language Syntax Quick Guide

<table>
  <thead>
    <tr>
      <th>
        In Slide
      </th>
      <th>
        In Code
      </th>
      <th>
        Analogy
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$x$</td>
      <td><pre>VAR "x"</pre></td>
      <td><pre><code class="hljs">x</code></pre></td>
    </tr>
    <tr>
      <td>$\lambda x.e$<br>$\lambda (x\colon t).e$</td>
      <td><pre>LAM ("x", e)
LAM ("x", t, e)
ALAM ("x", t, e)
</pre></td>
      <td>
        <pre><code class="hljs">\x -> e
function (x) { return e; }
\(x :: t) -> e
(x : t) => e
[???](t x) { return e; }
</code></pre>
      </td>
    </tr>
    <tr>
      <td>$e_1\;e_2$</td>
      <td><pre>AP (e1, e2)</pre></td>
      <td>
        <pre><code class="hljs">e1 e2
e1(e2)
</code></pre>
      </td>
    </tr>
    <tr>
      <td>$\mathbf{let}\;x=e_1\;\mathbf{in}\;e_2$</td>
      <td><pre>LET ("x", e1, e2)</pre></td>
      <td><pre><code class="hljs">let x = e1 in e2
val x = e1; e2
</code></pre></td>
    </tr>
    <tr>
      <td>$e \colon t$</td>
      <td><pre>ANNO (e,t)</pre></td>
      <td><pre><code class="hljs">e :: t
</code></pre></td>
    </tr>
    <tr>
      <td>$\Lambda \alpha.e$</td>
      <td><pre>TLAM ("a", e)</pre></td>
      <td><pre><code class="hljs">def foo[a](...) = ...
fn bar&amp;lt;a&amp;gt;(...) { ... }
template&amp;lt;typename a&amp;gt; e
</code></pre></td>
    </tr>
    <tr>
      <td>$e\;[t]$</td>
      <td><pre>TAP (e, t)</pre></td>
      <td><pre><code class="hljs">e&amp;lt;t&amp;gt;()
</code></pre></td>
    </tr>
  </tbody>
</table>
</textarea>
    <script src="./remark-0.10.2.min.js" type="text/javascript"></script>
    <script type="text/javascript">
      var slideshow = remark.create({
        highlightStyle: 'ir_black'
      });
      MathJax.Hub.Config({
        "HTML-CSS": { scale: 75 },
        tex2jax: {
          skipTags: ['code', 'script', 'noscript', 'style' ,'textarea', 'pre'],
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['\\[', '\\]']]
        }
      });
      MathJax.Hub.Configured();
    </script>
    <div class="remark-notes-area">hello world</div>
</body></html>
