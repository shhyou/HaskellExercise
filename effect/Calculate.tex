\documentclass{article}

\usepackage[fleqn]{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[margin=2.5cm]{geometry}

\usepackage{listings}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

\newcommand{\hdata}{\mathbf{data}}
\newcommand{\hclass}{\mathbf{class}}
\newcommand{\hinstance}{\mathbf{instance}}
\newcommand{\hwhere}{\mathbf{where}}
\newcommand{\hcase}{\mathbf{case}}
\newcommand{\hof}{\mathbf{of}}
\newcommand{\hFunctor}{\text{Functor}}
\newcommand{\hMaybe}{\text{Maybe}}
\newcommand{\hEither}{\text{Either}}
\newcommand{\hbind}{>\!\!\!>\!\!\!=}
\newcommand{\happend}{+\!\!\!+}
\newcommand{\ty}{:\!:}
\newcommand{\C}[1]{\text{#1}}
\newcommand{\Cbar}{\;\mathbf{|}\;}

% command for this file only
\newcommand{\U}{\bigcup\nolimits}

\makeatletter
\newcommand*\idstyle{%
        \expandafter\id@style\the\lst@token\relax
}
\def\id@style#1#2\relax{%
  \ifcat#1\relax\else
    \ifnum`#1<\uccode`#1%
      \it
    \else
      \ifnum`#1>\uccode`#1%
        \it
      \fi
    \fi
  \fi
}
\makeatother

\lstdefinelanguage{HaskellUlisses} {
	%basicstyle=\ttfamily \small,
	basicstyle=\linespread{1.2}\selectfont\small,
	columns=fullflexible,     %%
	keepspaces=true,          %%
	identifierstyle=\idstyle, %%
	morekeywords={data,class,instance,case,of,where,let,in,do,if,then,else},
	sensitive=true,
%	morecomment=[l][\color{gray_ulisses}\small\textit]{--},
%	morecomment=[s][\color{gray_ulisses}\small\textit]{\{-}{-\}},
	morecomment=[l][\small\textit]{--},
	morecomment=[s][\small\textit]{\{-}{-\}},
	morestring=[b]",
	stringstyle=\color{red},
	showstringspaces=false,
	numberstyle=\tiny,
	numberblanklines=true,
	showspaces=false,
	breaklines=true,
	showtabs=false
}

\lstnewenvironment{code}{\lstset{language=HaskellUlisses,mathescape=true}}{}
%{\textbf{Haskell Code} \hspace{1cm} \hrulefill \lstset{language=HaskellUlisses,mathescape=true}}
%{\hrulesmallskip}

\begin{document}
\subsection*{Open Union}
\begin{code}
data $\U_{rs}$ w
data (a :: $* \to *$) $\rhd$ b
instance Functor  $\U_{rs}$ where

class (t :: $* \to *$) $\in$ rs where
instance t $\in$ (t $\rhd$ rs) where
instance t $\in$ rs $\Rightarrow$ t $\in$ (t' $\rhd$ rs) where

inj :: (Functor t, t $\in$ rs) $\Rightarrow$ t v $\to$ $\U_{rs}$ v
prj :: t $\in$ rs $\Rightarrow$ $\U_{rs}$ v $\to$ Maybe (t v)
decomp :: $\U_{t \rhd rs}$ v $\to$ Either ($\U_{rs}$ v) (t v)
\end{code}

\newpage
\subsection*{Coroutine Data Type}
\begin{code}
data Eff rs a = Eff { runEff :: $\forall$w. (a $\to$ VE rs w) $\to$ VE rs w }
data VE rs w = Val x
                     | E ($\U_{rs}$ (VE rs w))

send :: ($\forall$w. (a $\to$ w) $\to$ $\U_{rs}$ w) $\to$ Eff rs a
send f = Eff ($\lambda$k $\to$ E (f k))

withHandler :: Functor t
                $\Rightarrow$ (a $\to$ Eff rs w)
                $\to$ (t (VE a (t $\rhd$ rs)) $\to$ Eff rs w)
                $\to$ VE a (t $\rhd$ rs)
                $\to$ Eff rs w
withHandler valHandler effHandler (Val x) = valHandler x
withHandler valHandler effHandler (E un) = case decomp un of
    Right tv $\to$ effHandler tv
    Left u $\to$ send ($\lambda$k $\to$ fmap k u) $\hbind$ withHandler valHandler effHandler

-- pure computations
data Void
runPure :: Eff Void a $\to$ a
runPure m = case runEff m Val of
  Val x $\to$ x

-- state
data State s v = GetState (s $\to$ v)
                     | SetState s (() $\to$ v)
runState :: s $\to$ Eff (State s $\rhd$ rs) a $\to$ Eff rs a
runState s m = handleSt (state s) (runEff m Val) where
    handleSt = withHandler return
    state s (GetState k) = handleSt (state s) (k s)
    state s (PutState s$'$ k) = handleSt (state s$'$) (k ())

-- error
data Error e v = Error e
runError :: Eff (Error e $\rhd$ rs) a $\to$ Eff rs (Either e a)
runError m = handleErr (runEff m Val) where
    handleErr = withHandler (return $\circ$ Right) ($\lambda$(Error e) $\to$ return (Left e))
\end{code}
\subsection*{Calculation}
\begin{code}
abc
\end{code}
\subsection*{{\ttfamily ListT} done..}
done wrong:
\begin{code}
newtype ListT m a = ListT { runListT :: m [a] }
wrap a = [a]

instance Monad m $\Rightarrow$ Monad (ListT m) where
    return = ListT $\circ$ return $\circ$ wrap
    (ListT m) $\hbind$ f = ListT (m $\hbind$ mapM (runListT $\circ$ f) $\hbind$ return $\circ$ concat)

instance MonadTrans ListT where
    lift m = ListT (m $\hbind$ return $\circ$ wrap)
\end{code}
monad laws:
\begin{enumerate}
\item $return\: x \hbind f = f\, x$
\begin{code}
   return x $\hbind$ f
-- definition of return
= ListT (return [x]) $\hbind$ f
-- definition of ($\hbind$)
= ListT (return [x] $\hbind$ mapM (runListT $\circ$ f) $\hbind$ return $\circ$ concat)
-- m is a monad
= ListT (mapM (runListT $\circ$ f) [x] $\hbind$ return $\circ$ concat)
-- definition of mapM
= ListT (runListT (f x) $\hbind$ return $\circ$ wrap $\hbind$ return $\circ$ concat)
-- m is a monad
= ListT (runListT (f x) $\hbind$ $\lambda$y $\to$ return (wrap y) $\hbind$ return $\circ$ concat)
= ListT (runListT (f x) $\hbind$ $\lambda$y $\to$ return (concat [y]))
= ListT (runListT (f x) $\hbind$ $\lambda$y $\to$ return y)
= ListT (runListT (f x) $\hbind$ return)
-- m is a monad
= ListT (runListT (f x)))
= f x
\end{code}
\item $m \hbind return = m$
\begin{code}
   m $\hbind$ return
= ListT (runListT m $\hbind$ mapM (runListT $\circ$ (ListT $\circ$ return $\circ$ wrap)) $\hbind$ return $\circ$ concat)
= ListT (runListT m $\hbind$ mapM (return $\circ$ wrap) $\hbind$ return $\circ$ concat)
-- ?mapM_and_concat
= ListT (runListT m $\hbind$ return)
= m

-- ?mapM_and_concat: mapM (return $\circ$ wrap) xs $\hbind$ return $\circ$ concat = return xs
-- base case
   mapM (return $\circ$ wrap) [] $\hbind$ return $\circ$ concat
= return []
-- inductive case
   mapM (return $\circ$ wrap) (x:xs) $\hbind$ return $\circ$ concat
= (return [x] $\hbind$ $\lambda$x$'$ $\to$ mapM (return $\circ$ wrap) xs $\hbind$ $\lambda$xs$'$ $\to$ return (x$'$:xs$'$)) $\hbind$ return $\circ$ concat
= (mapM (return $\circ$ wrap) xs $\hbind$ $\lambda$xs$'$ $\to$ return ([x]:xs$'$)) $\hbind$ return $\circ$ concat
-- m is a monad
= (mapM (return $\circ$ wrap) xs $\hbind$ $\lambda$xs$'$ $\to$ return ([x]:xs$'$)) $\hbind$ return $\circ$ concat
-- m is a monad
= mapM (return $\circ$ wrap) xs $\hbind$ $\lambda$xs$'$ $\to$ return ([x]:xs$'$) $\hbind$ return $\circ$ concat
= mapM (return $\circ$ wrap) xs $\hbind$ $\lambda$xs$'$ $\to$ return (concat ([x]:xs$'$))
= mapM (return $\circ$ wrap) xs $\hbind$ $\lambda$xs$'$ $\to$ return ([x] $\happend$ concat xs$'$)
-- m is a monad
= mapM (return $\circ$ wrap) xs $\hbind$ $\lambda$xs$'$ $\to$ return (concat xs$'$) $\hbind$ $\lambda$ys $\to$ return ([x] $\happend$ ys)
-- m is a monad
= mapM (return $\circ$ wrap) xs $\hbind$ return $\circ$ concat $\hbind$ $\lambda$ys $\to$ return ([x] $\happend$ ys)
-- induction hypothesis
= return xs $\hbind$ $\lambda$ys $\to$ return ([x] $\happend$ ys)
= return ([x] $\happend$ xs)
= return (x:xs)
\end{code}
\item $(m \hbind f) \hbind g) = m \hbind (\lambda x \to f\, x \hbind g)$
\end{enumerate}
\end{document}
%\definecolor{gray_ulisses}{gray}{0.55}
%\definecolor{castanho_ulisses}{rgb}{0.71,0.33,0.14}
%\definecolor{preto_ulisses}{rgb}{0.41,0.20,0.04}
%\definecolor{green_ulises}{rgb}{0.2,0.75,0}
%	emph=
%	{[1]
%%		FilePath,IOError,abs,acos,acosh,all,and,any,appendFile,approxRational,asTypeOf,asin,
%		abs,acos,acosh,all,and,any,appendFile,approxRational,asTypeOf,asin,
%		asinh,atan,atan2,atanh,basicIORun,break,catch,ceiling,chr,compare,concat,concatMap,
%		const,cos,cosh,curry,cycle,decodeFloat,denominator,digitToInt,div,divMod,drop,
%		dropWhile,either,elem,encodeFloat,enumFrom,enumFromThen,enumFromThenTo,enumFromTo,
%		error,even,exp,exponent,fail,filter,flip,floatDigits,floatRadix,floatRange,floor,
%		fmap,foldl,foldl1,foldr,foldr1,fromDouble,fromEnum,fromInt,fromInteger,fromIntegral,
%		fromRational,fst,gcd,getChar,getContents,getLine,head,id,inRange,index,init,intToDigit,
%		interact,ioError,isAlpha,isAlphaNum,isAscii,isControl,isDenormalized,isDigit,isHexDigit,
%		isIEEE,isInfinite,isLower,isNaN,isNegativeZero,isOctDigit,isPrint,isSpace,isUpper,iterate,
%		last,lcm,length,lex,lexDigits,lexLitChar,lines,log,logBase,lookup,map,mapM,mapM_,max,
%		maxBound,maximum,maybe,min,minBound,minimum,mod,negate,not,notElem,null,numerator,odd,
%		or,ord,otherwise,pi,pred,primExitWith,print,product,properFraction,putChar,putStr,putStrLn,quot,
%		quotRem,range,rangeSize,read,readDec,readFile,readFloat,readHex,readIO,readInt,readList,readLitChar,
%		readLn,readOct,readParen,readSigned,reads,readsPrec,realToFrac,recip,rem,repeat,replicate,return,
%		reverse,round,scaleFloat,scanl,scanl1,scanr,scanr1,seq,sequence,sequence_,show,showChar,showInt,
%		showList,showLitChar,showParen,showSigned,showString,shows,showsPrec,significand,signum,sin,
%		sinh,snd,span,splitAt,sqrt,subtract,succ,sum,tail,take,takeWhile,tan,tanh,threadToIOResult,toEnum,
%		toInt,toInteger,toLower,toRational,toUpper,truncate,uncurry,undefined,unlines,until,unwords,unzip,
%		unzip3,userError,words,writeFile,zip,zip3,zipWith,zipWith3,listArray,doParse
%	},
%	emphstyle={[1]\color{blue}\it},
%	emph=
%	{[2]
%		Bool,Char,Double,Either,Float,IO,Integer,Int,Maybe,Ordering,Rational,Ratio,ReadS,ShowS,String,
%		Word8,InPacket
%	},
%	emphstyle={[2]\color{castanho_ulisses}\textnormal},
%	emph=
%	{[3]
%		case,class,data,deriving,do,else,if,import,in,infixl,infixr,instance,let,
%		module,of,primitive,then,type,where
%	},
%	emphstyle={[3]\color{preto_ulisses}\textbf},
%	emph=
%	{[4]
%		quot,rem,div,mod,elem,notElem,seq
%	},
%	emphstyle={[4]\color{castanho_ulisses}\textbf},
%	emph=
%	{[5]
%		EQ,False,GT,Just,LT,Left,Nothing,Right,True,Show,Eq,Ord,Num
%	},
%	emphstyle={[5]\color{preto_ulisses}\textbf}
